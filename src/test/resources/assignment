1.
	Given a string of odd length, return the middle 3 characters from the string, 
	so the string <b>"Monitor"</b> yields <b>"nit"</b>. 
	If the string length is less than 3, return the string as is. <br> <br>

	<b>EXPECTATIONS:</b><br>
	middleThree("bunny") <b>---></b> "unn" <br>
	middleThree("peter") <b>---></b> "ete" <br>
	middleThree("Jamaica") <b>---></b>"mai" <br>

	2.
	The birds in Florida like to sing during favorable temperatures. 
	In particular, they sing if the temperature is between 60 and 90 (inclusive). 
	Unless it is summer, then the upper limit is 100 instead of 90. 
	Given an int temperature and a boolean isSummer, 
	return true if the birds are singing and false otherwise. <br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		birdsSinging(70, false)   <b>---></b> true <br>
		birdsSinging(95, false)    <b>---></b> false <br>
		birdsSinging(95, true) <b>---></b> true <br>
		
	3.
	Given three ints, first, second, third, return true if second is greater than first, and third is 
	greater than second. However, with the exception that if the parameter "itsOk" is true, 
	second does not need to be greater than first but still better be less than third.
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		isOrdered(1, 2, 4, false)   <b>---></b> true <br>
		isOrdered(1, 2, 1, false)    <b>---></b> false <br>
		isOrdered(1, 1, 2, true) <b>---></b> true <br>
	 
	 4.
	 We'll say a number is cool if it's a multiple of 11 or if it is one more than a multiple of 11. 
	Return true if the given non-negative number is cool. Use the % "modulus" operator 
	we spoke about in the prerequisite section. Watch the lesson on modulus if you need to review
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		isCool(22)   <b>---></b> true <br>
		isCool(23)    <b>---></b> true <br>
		isCool(24) <b>---></b> false <br>
		
	5.
	Given an int n, return the string form of the number followed by "!". 
	So if the int is for example 13 this method should return "13!". 
	However the catch is that if the number is divisible by 3 the method should return "Fizz!" 
	instead of the number, and if the number is divisible by 5 it should return "Buzz!", 
	and if divisible by both 3 and 5, use "FizzBuzz!". Youâ€™ll need to use the % "mod" 
	for computing the remainder after division, so 23 % 10 yields 3. 

	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		fizzyWizzy(1)   <b>---></b> "1!" <br>
		fizzyWizzy(2)    <b>---></b> "2!" <br>
		fizzyWizzy(3) <b>---></b> "Fizz!" <br>
	
	6. 
	Given 3 int arguments - a, b, c, return their sum. However, if one of the arguments 
	is the same as any of the other ones, that number should not count towards the sum. 
	So basically you only sum unique numbers, not duplicates
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		sumUnique(1, 2, 3)   <b>---></b> 6 <br>
		sumUnique(3, 2, 3)    <b>---></b> 2 <br>
		sumUnique(3, 3, 3) <b>---></b> 0 <br>
		
	7. 
	Given 2 positive int arguments (a, b), return whichever argument is 
	nearest to the number 21 without going over.
	Return 0 if they both go over 21. 
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		nearestTwentyOne(19, 21)   <b>---></b> 21 <br>
		nearestTwentyOne(21, 19)    <b>---></b> 21 <br>
		nearestTwentyOne(19, 22) <b>---></b> 19 <br>
		nearestTwentyOne(32, 22) <b>---></b> 0 <br>
		
	8.
	Given 3 int arguments, a b c, return their sum. However, if one of the arguments is 13 
	then it does not count towards the sum and arguments to it's right do not count either. 
	So for example, if b is 13, then both b and c do not count. 
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		partialSum(1, 2, 3)   <b>---></b> 6 <br>
		partialSum(1, 2, 13)    <b>---></b> 3 <br>
		partialSum(1, 13, 3) <b>---></b> 1 <br>
	9.
	Given a string, return a string where for every char in the original, append another. 
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		repeatChar("The")  <b>---></b>"TThhee"<br>
		repeatChar("AAbb")    <b>---></b> "AAAAbbbb" <br>
		repeatChar("Hi-There") <b>---></b> "HHii--TThheerree" <br>
	
	10.
	Return a version of the given string, where for every star (*) 
	in the string the star and the chars immediately to its left and right are gone. 
	So "ab*cd" yields "ad" and "ab**cd" also yields "ad". 	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		starKill("cd*zq")  <b>---></b>"cq"<br>
		starKill("ab**cd")    <b>---></b> "ad" <br>
		starKill("wacy*xko") <b>---></b> "wacko" <br>
	
	11.
	Given an array of strings, return the count of the number of strings with the given length	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		wordsCount({"a", "bb", "b", "ccc"}, 1) <b>---></b> 2<br>
		wordsCount({"a", "bb", "b", "ccc"}, 3) <b>---></b> 1 <br>
		wordsCount({"a", "bb", "b", "ccc"}, 4) <b>---></b> 0 <br>
		
	12.
	Given 2 arrays that are the same length containing strings, compare the 1st string in one array 
	to the 1st string in the other array, the 2nd to the 2nd and so on. 
	Count the number of times that the 2 strings are non-empty and start with the same char. 
	The strings may be any length, including 0. 	
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		matchingChar({"aa", "bb", "cc"}, {"aaa", "xx", "bb"})  <b>---></b> 1<br>
		matchingChar({"aa", "bb", "cc"}, {"aaa", "b", "bb"}) <b>---></b> 2 <br>
		matchingChar({"aa", "bb", "cc"}, {"", "", "ccc"}) <b>---></b> 1 <br>
		
	13.
	Given a string, return the length of the longest streak of the same chars in the string. 

	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		longestStreak("hayyeu") <b>---></b> 2<br>
		longestStreak("XPNzzzddOOOxx")  <b>---></b> 3 <br>
		longestStreak("")  <b>---></b> 0 <br>
		
	14.
	Given a string, compute recursively (no loops) the number of times 
		lowercase "yo" appears in the string.
	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		yoYo("xhyoxx") <b>---></b> 1<br>
		yoYo("nyonnyon")<b>---></b> 2 <br>
		yoYo("yo")  <b>---></b> 1 <br>
		
	15.
	Given a string, compute recursively a new string where all the 
		lowercase 'o' chars have been moved to the end of the string.

	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		endoo("oore") <b>---></b> reoo<br>
		endoo("oohoi") <b>---></b> hiooo <br>
		endoo("oanotgo") <b>---></b> antgooo <br>
		
	16.
	Given a string, compute recursively a new string where identical chars 
	that are adjacent in the original string are separated from each other by a "-".

	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		repeatHyphen("hello") <b>---></b> hel-lo<br>
		repeatHyphen("xxyy") <b>---></b> x-xy-y <br>
		repeatHyphen("aaaa") <b>---></b> a-a-a-a <br>
		
	17.
	Given a string that contains a single pair of brackets, compute recursively a new string made of 
	only of the brackets and their contents, so "xyz[abc]123" yields "[abc]".

	<br>
	<br>

	 * <b>EXPECTATIONS:</b><br>
		insideBrackets("xyz[abc]123") <b>---></b> [abc]<br>
		insideBrackets("x[hello]") <b>---></b> [hello] <br>
		insideBrackets("[xy]1") <b>---></b> [xy] <br>
	 */
	 
	18.
	/**
	 * Add both parameters (a & b) together and 
	 * subtract the number 3 and return the result<br>
	 * <br> 
	 *
	 * <b>EXPECTATIONS:</b><br>
		sumMinus3(2, 5) <b>---></b> 4 <br>
		sumMinus3(2, 1)  <b>---></b> 0 <br>
		sumMinus3(0, 2) <b>---></b> -1 <br>
	 */
	 